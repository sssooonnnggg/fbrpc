#include <filesystem>
#include <fstream>
#include <optional>

#include "flatbuffers/idl.h"

#include "core/ssLogger.h"

#include "ssPrinter.h"
#include "ssGenerator.h"

namespace fbrpc
{
	namespace
	{
		constexpr std::array<unsigned char, 3> Utf8Bom = { 0xEF, 0xBB, 0xBF };

		constexpr auto FileHeader = R"#(
//
// automatically generated by the fbrpc generator, do not modify
//

#pragma once

)#";
	}

	bool sGenerator::start(std::string_view protoFilePath, std::string_view outputDirPath)
	{
		m_outputDirPath = outputDirPath;

		std::filesystem::path protoPath(protoFilePath);
		if (!std::filesystem::exists(protoPath))
		{
			logger().error("proto path doesn't exist", protoFilePath);
			return false;
		}

		std::string sourceName = protoPath.filename().string();
		std::string parentPath = protoPath.parent_path().string();
		std::vector<const char*> includePath = { parentPath.c_str(), nullptr };

		std::ifstream file(protoFilePath.data(), std::ios_base::binary | std::ios_base::in);
		if (!file.is_open())
		{
			logger().error("read proto file failed", protoFilePath);
			return false;
		}

		std::vector<char> buffer(std::istreambuf_iterator<char>(file), {});
		buffer.push_back('\0');

		std::size_t offset = 0;
		if (buffer.size() > 3 
			&& static_cast<unsigned char>(buffer[0]) == Utf8Bom[0]
			&& static_cast<unsigned char>(buffer[1]) == Utf8Bom[1]
			&& static_cast<unsigned char>(buffer[2]) == Utf8Bom[2])
			offset = 3;

		flatbuffers::Parser parser;
		if (!parser.Parse(&buffer[0] + offset, &includePath[0], sourceName.c_str()))
		{
			logger().error("parse proto file failed", parser.error_);
			return false;
		}

		const auto& services = parser.services_.vec;
		if (services.size() == 0)
		{
			logger().error("no service found");
			return false;
		}

		if (services.size() > 1)
		{
			logger().error("more than one service found");
			return false;
		}

		auto service = services[0];

		if (service->name + ".fbs" != sourceName)
		{
			logger().error("mismatch between service name and file name, service name:", service->name, ",service file name:", sourceName);
			return false;
		}

		auto namespaces = service->defined_namespace->components;
		if (namespaces.size() > 1)
		{
			logger().error("unsupport nested namespace");
			return false;
		}

		if (!generateServiceFile(service))
			return false;

		if (!generateStubFile(service))
			return false;
		
		return true;
	}

	bool sGenerator::generateServiceFile(flatbuffers::ServiceDef* service)
	{
		std::string serviceName = service->name;
		auto namespaces = service->defined_namespace->components;

		sPrinter printer;
		printer.addContent(FileHeader);
		printer.addInclude("core/ssPromise.h");
		printer.addInclude("interface/ssService.h");
		printer.addInclude(serviceName + "_generated.h");
		printer.nextLine();

		{
			printer.addContent("using namespace fbrpc;");
			printer.nextLine();

			std::unique_ptr<sPrinter::sScope> namespaceScope;
			if (!namespaces.empty())
				namespaceScope = printer.addNamespace(namespaces[0]);

			{
				auto className = serviceName + "Service";
				auto classScope = printer.addClass(className, "sService");
				printer.addClassAccessSpecifier("public:");
				printer.addContent(
					std::string(R"#(std::string name() const override { return ")#") + className + std::string(R"#("; })#"));

				for (auto call : service->calls.vec)
				{
					auto apiName = call->name;
					auto requestName = call->request->name;
					auto responseName = call->response->name;
					printer.addContent("virtual void " + apiName + "(const " + requestName + "* request, std::unique_ptr<sPromise<" 
						+ responseName + ">> response) = 0; ");
				}

				printer.nextLine();
				printer.addContent("void init() override");
				{
					auto fucntion = printer.addScope();
					for (auto call : service->calls.vec)
					{
						auto apiName = call->name;
						auto requestName = call->request->name;
						auto responseName = call->response->name;

						printer.addContent(R"#(
addApiWrapper(std::hash<std::string>{}(")#" + apiName + R"#("), [this](sBufferView buffer, sResponder responder)
	{
		auto* request = flatbuffers::GetRoot<)#" + requestName + R"#(>(reinterpret_cast<const void*>(buffer.data));
		auto promise = createPromise<)#" + responseName + R"#(>();
		sUniqueFunction<void()> sendResponse = [capturedPromise = promise.get(), capturedResponder = std::move(responder)]() mutable
		{
			capturedResponder(sBuffer::clone(capturedPromise->builder()));
		};
		promise->bind(std::move(sendResponse));
		)#" + apiName + R"#((request, std::move(promise));
	}
);)#");
					}
				}
			}
		}

		return writeFile(printer.getOutput(), serviceName + "Service_generated.h");
	}

	bool sGenerator::generateStubFile(flatbuffers::ServiceDef* service)
	{
		std::string serviceName = service->name;
		auto namespaces = service->defined_namespace->components;

		sPrinter printer;
		printer.addContent(FileHeader);
		printer.addInclude("interface/ssStub.h");
		printer.addInclude("core/ssBuffer.h");
		printer.addInclude(serviceName + "_generated.h");
		printer.nextLine();

		{
			printer.addContent("using namespace fbrpc;");
			printer.nextLine();

			std::unique_ptr<sPrinter::sScope> namespaceScope;
			if (!namespaces.empty())
				namespaceScope = printer.addNamespace(namespaces[0]);

			{
				auto className = serviceName + "Stub";
				auto classScope = printer.addClass(className, "sStub");
				printer.addClassAccessSpecifier("public:");
				printer.addContent(className + "(sFlatBufferRpcClient* client): sStub(client) {}");
				printer.addContent(
					R"#(static std::size_t serviceHash() { static auto hash = std::hash<std::string>{}(")#" + serviceName + R"#(Service"); return hash; })#");
				printer.addContent(
					R"#(static std::size_t typeHash() { static auto hash = std::hash<std::string>{}(")#" + className + R"#("); return hash; })#");
				printer.addContent("std::size_t hash() const override { return typeHash(); }");

				for (auto call : service->calls.vec)
				{
					auto apiName = call->name;
					auto requestName = call->request->name;
					auto responseName = call->response->name;

					printer.nextLine();
					printer.addContent(
						std::string("using ") + responseName + "Handler = std::function<void(const " + responseName + "*)>;");
					printer.addContent(
						std::string("void ") + apiName + "(flatbuffers::Offset<" + requestName + "> request, "
						+ responseName + "Handler handler)"
					);

					auto functionScope = printer.addScope();
					printer.addContent(R"#(static auto apiHash = std::hash<std::string>{}(")#" + apiName + R"#(");
builder().Finish(request);
call(serviceHash(), apiHash, sBuffer::clone(builder()), [handler](sBufferView buffer)
	{
		auto* response = flatbuffers::GetRoot<)#" + responseName + R"#(>(buffer.data);
		handler(response);
	}
);
builder().Clear();)#");
				}
			}
		}

		return writeFile(printer.getOutput(), serviceName + "Stub_generated.h");
	}

	bool sGenerator::writeFile(std::string content, std::string name)
	{
		std::filesystem::path outputPath(m_outputDirPath);
		outputPath /= name;

		std::ofstream file(outputPath.string(), std::ios_base::binary);
		if (!file.is_open())
		{
			logger().error("genenrate file failed", outputPath.string());
			return false;
		}

		file << Utf8Bom[0] << Utf8Bom[1] << Utf8Bom[2] << content;
		file.close();
		return true;
	}
}