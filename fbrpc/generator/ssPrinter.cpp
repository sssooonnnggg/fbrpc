#include <cassert>

#include "ssPrinter.h"
#include "fbrpc/core/ssLogger.h"

namespace
{
	constexpr auto FileHeader = R"#(//
// automatically generated by the fbrpc generator, do not modify
//
)#";
}

namespace fbrpc
{
	sPrinter::sScope::sScope(sPrinter* printer, sCallback onEnter, sCallback onLeave)
		: m_printer(printer), m_onEnter(std::move(onEnter)), m_onLeave(std::move(onLeave))
	{
		if (m_onEnter)
			m_onEnter();

		m_printer->setIndent(m_printer->indent() + m_printer->config().indentSpaceCount);
	}

	sPrinter::sScope::~sScope()
	{
		m_printer->setIndent(m_printer->indent() - m_printer->config().indentSpaceCount);
		assert(m_printer->indent() >= 0);

		if (m_onLeave)
			m_onLeave();
	}

	void sPrinter::addHeader()
	{
		addContent(FileHeader);
	}

	void sPrinter::nextLine(std::size_t lineCount)
	{
		for (auto i = 0; i < lineCount; ++i)
			m_output = m_output + config().lineEndings;
	}

	void sPrinter::addContent(std::string_view lines, sVarsMap vars)
	{
		auto lineEndings = config().lineEndings;
		std::size_t offset = 0;
		do 
		{
			auto prev = offset;
			offset = lines.find_first_of(lineEndings, offset);
			if (offset == prev)
			{
				addSingleLine("");
			}
			else
			{
				auto singleLine = lines.substr(prev, offset == std::string::npos ? std::string::npos : (offset - prev));
				addSingleLine(singleLine, vars);
			}
			
			if (offset != std::string::npos)
				offset += lineEndings.size();

		} while (offset != std::string::npos);
	}

	void sPrinter::addSingleLine(std::string_view singleLine, sVarsMap vars)
	{
		std::string output;
		for (auto i = 0; i < singleLine.length();)
		{
			if (singleLine[i] == '$')
			{
				auto end = singleLine.find('$', i + 1);
				if (end == std::string_view::npos)
				{
					logger().error("except $ for variable, but not found");
					return;
				}
				std::string_view var = singleLine.substr(i + 1, end - (i + 1));
				auto value = vars.find(var);
				if (value == vars.end())
				{
					logger().error("can't find variable value for: ", var);
					return;
				}

				output += std::string(value->second);
				i = end + 1;
			}
			else
			{
				output += singleLine[i];
				++i;
			}

		}

		m_output = m_output + std::string(m_indent, ' ') + output + config().lineEndings;
	}

	std::size_t sPrinter::indent() const
	{
		return m_indent;
	}

	void sPrinter::setIndent(std::size_t indent)
	{
		m_indent = indent;
	}

	void sPrinter::setConfig(sPrinter::sConfig config)
	{
		m_config = std::move(config);
	}

	const sPrinter::sConfig& sPrinter::config() const
	{
		return m_config;
	}

	std::string sPrinter::getOutput()
	{
		return m_output;
	}
}