#include <cassert>

#include "ssPrinter.h"
#include "fbrpc/core/ssLogger.h"

namespace
{
	constexpr auto FileHeader = R"#(//
// automatically generated by the fbrpc generator, do not modify
//
)#";
}

namespace fbrpc
{
	sPrinter::sScope::sScope(sPrinter* printer, sCallback onEnter, sCallback onLeave)
		: m_printer(printer), m_onEnter(std::move(onEnter)), m_onLeave(std::move(onLeave))
	{
		if (m_onEnter)
			m_onEnter();

		m_printer->setIndent(m_printer->indent() + m_printer->config().indentSpaceCount);
	}

	sPrinter::sScope::~sScope()
	{
		m_printer->setIndent(m_printer->indent() - m_printer->config().indentSpaceCount);
		assert(m_printer->indent() >= 0);

		if (m_onLeave)
			m_onLeave();
	}

	void sPrinter::addHeader()
	{
		addContent(FileHeader);
	}

	void sPrinter::nextLine(std::size_t lineCount)
	{
		for (auto i = 0; i < lineCount; ++i)
			appendOrInsert(config().lineEndings);
	}

	std::size_t sPrinter::addContent(std::string_view lines, sVarsMap vars)
	{
		auto lineEndings = config().lineEndings;
		std::size_t offset = 0;
		do 
		{
			auto prev = offset;
			offset = lines.find_first_of(lineEndings, offset);
			if (offset == prev)
			{
				addSingleLine("");
			}
			else
			{
				auto singleLine = lines.substr(prev, offset == std::string::npos ? std::string::npos : (offset - prev));
				addSingleLine(singleLine, vars);
			}
			
			if (offset != std::string::npos)
				offset += lineEndings.size();

		} while (offset != std::string::npos);

		return m_output.length();
	}

	std::string sPrinter::format(std::string_view content, sVarsMap vars)
	{
		std::string output;
		for (auto i = 0; i < content.length();)
		{
			if (content[i] == '$')
			{
				auto end = content.find('$', i + 1);
				if (end == std::string_view::npos)
				{
					logger().error("except $ for variable, but not found");
					return output;
				}
				std::string_view var = content.substr(i + 1, end - (i + 1));
				auto value = vars.find(var);
				if (value == vars.end())
				{
					logger().error("can't find variable value for: ", var);
					return output;
				}

				output += std::string(value->second);
				i = end + 1;
			}
			else
			{
				output += content[i];
				++i;
			}
		}
		return output;
		}

	void sPrinter::addSingleLine(std::string_view singleLine, sVarsMap vars)
	{
		auto output = format(singleLine, vars);
		appendOrInsert(std::string(m_indent, ' ') + output + config().lineEndings);
	}

	std::size_t sPrinter::indent() const
	{
		return m_indent;
	}

	void sPrinter::setIndent(std::size_t indent)
	{
		m_indent = indent;
	}

	void sPrinter::setConfig(sPrinter::sConfig config)
	{
		m_config = std::move(config);
	}

	const sPrinter::sConfig& sPrinter::config() const
	{
		return m_config;
	}

	std::string sPrinter::getOutput()
	{
		return m_output;
	}

	void sPrinter::appendOrInsert(std::string_view str)
	{
		if (m_index == std::string::npos)
		{
			m_output += str;
		}
		else
		{
			m_output.insert(m_index, str);
			m_index += str.length();
		}
	}

	void sPrinter::moveTo(std::size_t index)
	{
		m_oldIndent = indent();
		setIndent(0);
		setIndex(index);
	}

	void sPrinter::moveBack()
	{
		setIndex(std::string::npos);
		setIndent(m_oldIndent);
	}
}